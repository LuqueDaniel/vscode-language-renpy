(* Recommended extension for EBNF syntax highlighting: https://marketplace.visualstudio.com/items?itemName=omkov.vscode-ebnf *)

(*===Tokens with definition===*)
(* 
    POSIX character classes defined using unicode categories 
    For POSIX see: https://www.regular-expressions.info/posixbrackets.html
    For unicode categories see: https://www.unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt
    For category breakdown see: https://www.unicode.org/Public/UCD/latest/ucd/DerivedCoreProperties.txt
*)
UPPER = "\p{Uppercase_Letter}";
LOWER = "\p{Lowercase_Letter}";
ALPHA = "\p{Letter}" | "\p{Letter_Number}";
LETTER = "\p{Letter}";
DIGIT = "\p{Digit}";
HEX_DIGIT = "\p{Hex_Digit}";
ALNUM = ALPHA | DIGIT;
WORD_CHAR = ALNUM | "\p{Connector_Punctuation}";
NEWLINE = "\r\n" | "\n" | "\r";
WHITESPACE = " " | "\t";
INDENT = ? Block opening sequence of WHITESPACE ?;
DEDENT = ? Block closing sequence of WHITESPACE less then INDENT ?;
CHARACTER = "\p{Any}";

IDENTIFIER = "\p{XID_Start}", { "\p{XID_Continue}" }; (* Based on Python specification. See: https://docs.python.org/3/reference/lexical_analysis.html#identifiers *)
RENPY_KEYWORD = "as" | "at" | "behind" | "call" | "expression" | "hide" | "if" | "in" | "image" | "init" | "jump" | "menu" | "onlayer" | "python" | "return" | "scene" | "show" | "with" | "while" | "zorder";
OPERATOR = "<>" | "<<" | "<=" | "<" | ">>" | ">=" | ">" | "!=" | "==" | "|" | "^" | "&" | "+" | "-" | "**" | "*" | "//" | "/" | "%" | "~";

HASH = HEX_DIGIT, { HEX_DIGIT };
INTEGER = [ "+" | "-" ], DIGIT, { DIGIT };
FLOAT = [ "+" | "-" ], ( DIGIT, { DIGIT }, [ ".", { DIGIT } ] | ".", DIGIT, { DIGIT } ), [ ( "e" | "E" ), [ "+" | "-" ], DIGIT, { DIGIT } ];

WORD = IDENTIFIER;
NAME = WORD - RENPY_KEYWORD;
DOTTED_NAME = NAME, { ".", NAME };
LABEL_NAME = ["."], NAME, [ ".", NAME ];
IMAGE_NAME_COMPONENT_NO_DASH = WORD_CHAR - "-", { WORD_CHAR - "-" };
IMAGE_NAME_COMPONENT = WORD_CHAR+;
IMAGE_NAME_NO_DASH = IMAGE_NAME_COMPONENT_NO_DASH, { WHITESPACE, IMAGE_NAME_COMPONENT_NO_DASH };
IMAGE_NAME = IMAGE_NAME_COMPONENT, { WHITESPACE, IMAGE_NAME_COMPONENT };

STYLE_PROPERTY_PREFIX =  [ "selected_" ], [ ("hover_" | "idle_" | "insensitive_" | "activate_") ];
STYLE_PROPERTY =  "activate_sound" | "adjust_spacing" | "aft_bar" | "aft_gutter" | "align" | "alt" | "altruby_style" | "anchor" | "antialias" | "area" | "background" | "bar_invert"
    | "bar_resizing" | "bar_vertical" | "base_bar" | "black_color" | "bold" | "bottom_bar" | "bottom_gutter" | "bottom_margin" | "bottom_padding" | "box_first_spacing" | "box_layout" | "box_reverse"
    | "box_spacing" | "box_wrap" | "box_wrap_spacing" | "caret" | "child" | "clipping" | "color" | "debug" | "drop_shadow" | "drop_shadow_color" | "enable_hover" | "first_indent"
    | "first_spacing" | "fit_first" | "focus_mask" | "focus_rect" | "font" | "fore_bar" | "fore_gutter" | "foreground" | "hinting" | "hover_sound" | "hyperlink_functions" | "italic"
    | "justify" | "kerning" | "key_events" | "keyboard_focus" | "language" | "layout" | "left_bar" | "left_gutter" | "left_margin" | "left_padding" | "line_leading" | "line_overlap_split"
    | "line_spacing" | "margin" | "maximum" | "min_width" | "minimum" | "minwidth" | "mipmap" | "modal" | "mouse" | "newline_indent" | "offset" | "order_reverse"
    | "outline_scaling" | "outlines" | "padding" | "pos" | "rest_indent" | "right_bar" | "right_gutter" | "right_margin" | "right_padding" | "ruby_style" | "size" | "size_group"
    | "slow_abortable" | "slow_cps" | "slow_cps_multiplier" | "slow_speed" | "sound" | "spacing" | "strikethrough" | "subpixel" | "subtitle_width" | "text_align" | "text_y_fudge" | "textalign"
    | "thumb" | "thumb_offset" | "thumb_shadow" | "time_policy" | "top_bar" | "top_gutter" | "top_margin" | "top_padding" | "underline" | "unscrollable" | "vertical" | "xalign"
    | "xanchor" | "xcenter" | "xfill" | "xfit" | "xmargin" | "xmaximum" | "xminimum" | "xoffset" | "xpadding" | "xpos" | "xsize" | "xspacing"
    | "xysize" | "yalign" | "yanchor" | "ycenter" | "yfill" | "yfit" | "ymargin" | "ymaximum" | "yminimum" | "yoffset" | "ypadding" | "ypos" | "ysize" | "yspacing";
STYLE_PROPERTY_NAME = [STYLE_PROPERTY_PREFIX], STYLE_PROPERTY;

PYTHON_EXPRESSION = ? any valid Python expression ?;
PYTHON_STRING = ? python string ?;
STRING = ? renpy string ?;


(*===Renpy Expressions===*)
as_expression = "as", NAME;
at_expression = "at", simple_expression_list;
onlayer_expression = "onlayer", NAME;
zorder_expression = "zorder", simple_expression;
behind_expression = "behind", NAME, {",", NAME};
if_expression = "if", PYTHON_EXPRESSION;
expression_clause = "expression", simple_expression;
from_expression = "from", LABEL_NAME;
with_expression = "with", simple_expression;

(* TODO: These 4 have some special rules that are not yet defined here *)
parameter = NAME, [ "=", PYTHON_EXPRESSION ];
parameters = "(", [ parameter, { ",", parameter } ], ")";
argument = [ NAME, "=" ], PYTHON_EXPRESSION;
arguments = "(", [ argument, { ",", argument } ], ")";

parenthesized_python = ( "(", PYTHON_EXPRESSION, ")" )
    | ( "[", PYTHON_EXPRESSION, "]" )
    | ( "{", PYTHON_EXPRESSION, "}" )
    ;

(* image specifier *)
image_specifier = [ expression_clause | IMAGE_NAME ], { image_specifier_clause };
image_specifier_clause = as_expression | at_expression | onlayer_expression | zorder_expression | behind_expression;

simple_expression = { OPERATOR }, ( PYTHON_STRING | NAME | FLOAT | parenthesized_python ), [ (".", NAME) | parenthesized_python ]
simple_operator_expression = simple_expression, { OPERATOR , simple_expression };
simple_expression_list = simple_expression, { ",", simple_expression };

(* style *)
style_is_clause = "is", WORD;
style_clear_clause = "clear";
style_take_clause = "take", NAME;
style_del_clause = "del", STYLE_PROPERTY_NAME;
style_variant_clause = "variant", simple_expression;
style_property_clause = STYLE_PROPERTY_NAME, simple_expression;

(*===Renpy Statements===*)
program = statement+;
block = statement+, DEDENT;
atl_block = atl_statement+, DEDENT;
style_block = style_clause_statement+, DEDENT;
python_block = python_statement+, DEDENT;

begin_block = ":", NEWLINE, INDENT, block;
begin_atl_block = ":", NEWLINE, INDENT, atl_block;
begin_style_block = ":", NEWLINE, INDENT, style_block;
begin_python_block = ":", NEWLINE, INDENT, python_block;

statement = if_statement 
    | while 
    | pass 
    | menu 
    | return 
    | jump
    | call
    | scene
    | show
    | show_layer
    | camera
    | hide
    | with
    | image
    | define
    | default
    | transform
    | one_line_python
    | python
    | label
    | init_offset
    | init_label
    | init
    | rpy_monologue
    | screen
    | testcase
    | translate
    | style
    | rpy_python
    | say
    | ;

(* if *)
if_clause = if_expression, begin_block;
elif_clause = "elif", PYTHON_EXPRESSION, begin_block;
else_clause = "else", begin_block;
if_statement = if_clause, { elif_clause }, [ else_clause ];

(* while *)
while = "while", PYTHON_EXPRESSION, begin_block;

(* pass *)
pass = "pass", NEWLINE;

(* return *)
return = "return", [ PYTHON_EXPRESSION ], NEWLINE;

(* jump *)
jump = "jump", ( expression_clause | LABEL_NAME ), NEWLINE;

(* call *)
call = "call", ( expression_clause, [ "pass" ] | LABEL_NAME ), [ arguments ], [ from_expression ], NEWLINE;

(* with *)
with = with_expression, NEWLINE;

(* say *)
say_who = simple_expression;
say_what = TRIPLE_STRING | STRING;
say_attributes = "-", {IMAGE_NAME_COMPONENT};
say_temporary_attributes = "@", say_attributes;
say = [say_who], [say_attributes], [say_temporary_attributes], say_what;

(* menu *)
menu = "menu", [ LABEL_NAME ], [ arguments ], menu_block;

(* menu block *)
menuitem_set = "set", PYTHON_EXPRESSION, NEWLINE;
menuitem_caption = say;
menuitem_choice = STRING, [ arguments ], [ if_expression ], begin_block;
menuitem_block_statement = menuitem_set | with | menuitem_caption | menuitem_choice;
menu_block = menuitem_block_statement, { menuitem_block_statement };

(* scene *)
scene = "scene", [ onlayer_expression ], [ image_specifier, [ with ] ], (begin_atl_block | NEWLINE);

(* show *)
show = "show", image_specifier, [ with ], (begin_atl_block | NEWLINE);
show_layer = "show", "layer", NAME, [ at_expression ], (begin_atl_block | NEWLINE);

(* hide *)
hide = "hide", image_specifier, [ with ], NEWLINE;

(* camera *)
camera = "camera", [ NAME ], [ at_expression ], (begin_atl_block | NEWLINE);

(* image *)
image = "image", IMAGE_NAME_NO_DASH, (begin_atl_block | "=", PYTHON_EXPRESSION, NEWLINE);

(* define *)
define = "define", [ INTEGER ], DOTTED_NAME, [ "[", PYTHON_EXPRESSION, "]" ], [ "+" | "|" ], "=", PYTHON_EXPRESSION, NEWLINE;

(* default *)
default = "default", [ INTEGER ], DOTTED_NAME, "=", PYTHON_EXPRESSION, NEWLINE;

(* transform *)
transform = "transform", [ INTEGER ], DOTTED_NAME, [ parameters ], begin_atl_block;

(* $ *)
one_line_python = "$", PYTHON_EXPRESSION, NEWLINE;

(* python *)
python = "python", [ "early" ], [ "hide" ], [ "in", DOTTED_NAME ], begin_python_block;

(* label *)
label = "label", LABEL_NAME, [ parameters ], [ "hide" ], begin_block;

(* init *)
init = "init", [ INTEGER ], ( begin_block | statement );
init_offset = "init", "offset", "=", [ INTEGER ], NEWLINE;
init_label = "init", label;

(* rpy monologue *)
rpy_monologue = "rpy", "monologue", ( "double" | "single" | "none" ), NEWLINE;

(* screen *)
screen = "screen" ? TODO ?;
testcase = ? TODO ?;
translate = "translate" ? TODO ?;
rpy_python = ? TODO ?;

(* style *)
style = "style", WORD, { style_clause }, ( begin_style_block | NEWLINE );
style_clause = style_is_clause 
    | style_clear_clause 
    | style_take_clause 
    | style_del_clause 
    | style_variant_clause 
    | style_property_clause
    ;

style_clause_statement = style_clause, NEWLINE;




(* GENERATED *)
EXPRESSION = "expression", simple_expression;

SCREEN = "screen", NAME, [ parameters ], ":";

USER_STATEMENT = "user", NAME, [ arguments ];

TRANSLATE = "translate", NAME, HASH, ":";
TRANSLATE_STRING = "translate", NAME, "strings", ":";
TRANSLATE_BLOCK = "translate", NAME, ( "python" | "style" ), ":";
TRANSLATE_EARLY_BLOCK = "translate early", NAME, ( "python" | "style" ), ":";

SCREEN = "screen", NAME, [ parameters ], ":";
SCREEN_PROPERTY = NAME, "=", PYTHON_EXPRESSION;
SCREEN_STYLE_PROPERTY = NAME, "=", PYTHON_EXPRESSION;
SCREEN_style = "style", NAME, { SCREEN_STYLE_PROPERTY }, ":";
SCREEN_USE = "use", NAME, [ arguments ];
SCREEN_VBAR = "|";
SCREEN_TAG = "$";
SCREEN_TEXT = PYTHON_STRING;
SCREEN_NL = "%";
SCREEN_SPACE = " ";
SCREEN_INDENT = "\t";
SCREEN_CHILD = SCREEN_PROPERTY | SCREEN_style | SCREEN_USE | SCREEN_VBAR | SCREEN_TAG | SCREEN_TEXT | NEWLINE | SCREEN_NL | SCREEN_SPACE | SCREEN_INDENT;
SCREEN_CHILDREN = { SCREEN_CHILD };